initSidebarItems({"enum":[["AnyValue",""],["ArrowDataType","The set of supported logical types. Each variant uniquely identifies a logical type, which define specific semantics to the data (e.g. how it should be represented). A [`DataType`] has an unique corresponding [`PhysicalType`], obtained via [`DataType::to_physical_type`], which uniquely identifies an in-memory representation of data. The [`DataType::Extension`] is special in that it augments a [`DataType`] with metadata to support custom types. Use `to_logical_type` to desugar such type and return its correspoding logical type."],["DataType",""],["TimeUnit","Time units defined in Arrow."]],"struct":[["BooleanType",""],["CategoricalType",""],["Date32Type",""],["Date64Type",""],["Field",""],["Float32Type",""],["Float64Type",""],["Int16Type",""],["Int32Type",""],["Int64Type",""],["Int8Type",""],["ListType",""],["ObjectType",""],["Schema",""],["Time64NanosecondType",""],["UInt16Type",""],["UInt32Type",""],["UInt64Type",""],["UInt8Type",""],["Utf8Type",""]],"trait":[["PolarsDataType",""],["PolarsFloatType",""],["PolarsIntegerType",""],["PolarsNumericType",""],["PolarsPrimitiveType",""],["PolarsSingleType","Any type that is not nested"],["ToPolarsType",""]],"type":[["BooleanChunked",""],["CategoricalChunked",""],["Date32Chunked",""],["Date64Chunked",""],["Float32Chunked",""],["Float64Chunked",""],["Int16Chunked",""],["Int32Chunked",""],["Int64Chunked",""],["Int8Chunked",""],["ListChunked",""],["ObjectChunked",""],["PlHashMap",""],["PlHashSet",""],["SchemaRef",""],["Time64NanosecondChunked",""],["UInt16Chunked",""],["UInt32Chunked",""],["UInt64Chunked",""],["UInt8Chunked",""],["Utf8Chunked",""]]});